---
authors:
- admin
date: '2019-09-24'
layout: post

title: 'Quantstrat logistic trading model'
subtitle: 'A simple backtested trading strategy in R'
summary: 'I use a simple logistic model to learn a little more about the quantstrat backtesting package in R'

categories: [Quantitative Finance]
projects: [trading]
tags: [quant finance, asset pricing, time series, backtesting]
---

```{r setup, include = FALSE, message = FALSE, warning = FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Over the past few months I have been taking a deeper look into the `quantstrat` backtesting package in R. At first there is a bit of a learning curve but once I understood the syntax everything became much more intuitive.

```{r packages, include = TRUE, message = FALSE, warning = FALSE}
library(quantstrat)
library(PerformanceAnalytics)
library(dplyr)
library(knitr)
library(kableExtra)
library(ggplot2)
library(tibble)
library(tidyquant)
```

The package expects some initialisation parameters which are used later when compiling the strategy. 

```{r, include = TRUE, message = FALSE, warning = FALSE}
set.seed(1234)

#setting up some initial parameters for the quantstrat trading model
initDate = "2007-01-01"
from <- "2017-01-01"
to <- "2018-12-01"
init_equity <- 1000
adjustment <- TRUE

.orderqty <- 10
.txnfees <- -10

currency('USD')
Sys.setenv(TZ = "UTC")
```

I use Yahoo Finance to collect the financial data for Google but we can import data directly from bloomberg terminal as well. I construct a very simplistic logistic strategy which can be switched out easily for a Machine Learning model.

```{r, include = TRUE, message = FALSE, warning = FALSE}
#Collect the data
symbols <- c('GOOG')
.data <- new.env()
getSymbols(symbols, from=from, to=to, src="yahoo", adjust=TRUE, env = .data)  

colnames(.data$GOOG) <- c("open", "high", "low", "close", "volume", "adjusted")

mdata <- .data$GOOG

```

#### Take a look at the data:
```{r, echo = FALSE, include = TRUE, message = FALSE, warning = FALSE}
mdata %>%
  head() %>%
  kable(caption = "Stock Data") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"), font_size = 12)
```


I create a naive binary variable which we will try to predict. The model is, if the closing price `today` is greater or equal to the `opening` price then the stock has gone up since (or matched) this mornings open price, therefore I assign a `1` and if the closing price was less than the open then the stock price has gone down since the morning open price, which is assigned `0`.

Now the problem is not a regression problem but a binary classification problem. I also create two base variables - a *Relative Strength Indicator* and a *Momentum Indicator* - feel free to add more technical indicators by looking at the `TTR` package.

```{r, include = TRUE, message = FALSE, warning = FALSE}
# create the dependent variable for a logistic regression
mdata$direction <- with(mdata, ifelse(close >= open, 1, 0))

#create two basic input variables - lagged
mdata$rsi <- RSI(mdata$close, nFast=14, nSlow = 26, nSig = 9, maType = SMA)
mdata$momentum <- momentum(mdata$close, n = 12)
```

I lag the dependent variables to `t-1` since we are trying to predct `Y` at time `t` using `t-1` predictors. I split the data into a *naive* train and test split - a rolling origin function would be better suited here, see [rolling origin](https://cran.r-project.org/web/ackages/greybox/vignettes/ro.html). Moreover this strategy is just for learning the functionality of the `quantstrat` package in R.

```{r, include = TRUE, message = FALSE, warning = FALSE}
mdata <- mdata[complete.cases(mdata), ] 
mdata$direction_fwd <- lag.xts(mdata$direction, k = -1)
# create a training and test set
train_date <- nrow(mdata) *0.8
train <- mdata[1:train_date,]
test <- mdata[-c(1:train_date),]
```

Using the Generalise Linear Model in R we can fit a model on the training data, `family = binomial` since we have a `0` or `1` binary classification problem now.

```{r, include = TRUE, message = FALSE, warning = FALSE}
#Run a simple logistic regression and obtain predicted probabilities
lm.fit <- glm(direction_fwd ~ rsi + momentum, data = train, family = binomial)
```

#### Summary Statistics  

```{r, include = TRUE, message = FALSE, warning = FALSE}
summary(lm.fit)
```

#### Make the predictions on the held out test set:

```{r, include = TRUE, message = FALSE, warning = FALSE}

pr.lm <- predict(lm.fit, test, type = "response")
test$pred_prob <- pr.lm

pr.lm %>%
  data.frame() %>%
  rownames_to_column("dates") %>%
  rename(preds = ".") %>%
  ggplot(aes(x = preds)) +
  geom_density() +
  geom_vline(aes(xintercept = mean(preds)), color = "blue", linetype = "dashed", size = 1) +
  theme_tq() +
  ggtitle("Probability predctions on the test set") +
  xlab("Density") +
  ylab("Predicted Probabilities")

```

Not great but we do only have two predictors. From here we can create a cut-off score and say that all probabilities greater than `0.6` we assign a 1, else if they are less than or equal to `0.6` we assign a `0`. We can see how accurate the model is:

```{r, include = TRUE, message = FALSE, warning = FALSE}
#Add our predictions to the TEST data if its greater than 0.6
test$prediction <- ifelse(pr.lm > 0.6, 1, 0)

paste0("Accuracy: ", mean(test$direction_fwd == test$prediction, na.rm = T))
```

#### Applying the model to a strategy

check:https://stackoverflow.com/questions/53713017/very-simple-quantstrat-trading-model-using-logistic-regression

```{r, include = TRUE, message = FALSE, warning = FALSE}
# Simple way to run applyStrategy is to make sure the data for the symbol is in a variable with its name, like so:
GOOG <- test


stock("GOOG", currency="USD", multiplier=1)
strategy.st <- portfolio.st <- account.st <- "LogisticRegressionStrategy"
rm.strat(strategy.st)
rm.strat(portfolio.st)
rm.strat(account.st)



initPortf(name = portfolio.st,
          symbols = symbols, 
          initDate = initDate, 
          currency = 'USD')

initAcct(name = account.st, 
         portfolios = portfolio.st, 
         initDate = initDate, 
         currency = 'USD',
         initEq = init_equity)

initOrders(portfolio.st,
           symbols = symbols,
           initDate = initDate)

strategy(strategy.st, store = TRUE)

nMult_orderqty <- 2
addPosLimit(portfolio.st, symbol = "GOOG", timestamp = initDate, maxpos = nMult_orderqty * .orderqty)

# Buy when prob exceeds 0.6 for the first time, using cross= TRUE
add.signal(strategy = strategy.st,
         name = "sigThreshold",
         arguments = list(threshold=0.6, column="pred_prob", relationship="gt", cross= TRUE),
         label = "longSig")

 #exit when prob drops below 0.5 for the first time
add.signal(strategy = strategy.st,
           name = "sigThreshold",
           arguments = list(threshold=0.5, column="pred_prob", relationship="lt", cross= TRUE),
           label = "exitLongSig")

# Adding the rules, enter at the low price when "prediction" = 1, taking transaction fees into account
add.rule(strategy = strategy.st,
         name = "ruleSignal",
         arguments = list(sigcol = "longSig",
                          sigval = 1,
                          orderqty = .orderqty,
                          ordertype = "market",
                          orderside = "long",
                          osFUN = osMaxPos,
                          prefer = "Open",  #Never kknow the low in advance. Use the open, as it is for the next day (be aware that the open price for bar data has its own problems too)
                          TxnFees = .txnfees, 
                          replace = FALSE),
         type = "enter",
         label = "EnterLONG")

# As soon as the Logistic regression predicts a "0" we dump all our shares in GOOG

add.rule(strategy.st, 
         name = "ruleSignal", 
         arguments = list(sigcol = "exitLongSig", 
                          sigval = 1, 
                          ordertype = "market", 
                          orderside = "long",
                          orderqty = "all", 
                          TxnFees = .txnfees, 
                          replace = TRUE), 
         type = "exit", 
         label = "Exit2SHORT")


applyStrategy(strategy.st, portfolios = portfolio.st)

updatePortf(portfolio.st)
updateAcct(account.st)
updateEndEq(account.st)

chart.Posn(portfolio.st, Symbol = "GOOG", 
           TA="add_SMA(n = 10, col = 2); add_SMA(n = 30, col = 4)")

```